<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ADAPT.jl</title><meta name="title" content="Home · ADAPT.jl"/><meta property="og:title" content="Home · ADAPT.jl"/><meta property="twitter:title" content="Home · ADAPT.jl"/><meta name="description" content="Documentation for ADAPT.jl."/><meta property="og:description" content="Documentation for ADAPT.jl."/><meta property="twitter:description" content="Documentation for ADAPT.jl."/><meta property="og:url" content="https://kmsherbertvt.github.io/ADAPT.jl/"/><meta property="twitter:url" content="https://kmsherbertvt.github.io/ADAPT.jl/"/><link rel="canonical" href="https://kmsherbertvt.github.io/ADAPT.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ADAPT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ADAPT"><a class="docs-heading-anchor" href="#ADAPT">ADAPT</a><a id="ADAPT-1"></a><a class="docs-heading-anchor-permalink" href="#ADAPT" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/kmsherbertvt/ADAPT.jl">ADAPT</a>.</p><ul><li><a href="#ADAPT.Basics.Callbacks"><code>ADAPT.Basics.Callbacks</code></a></li><li><a href="#ADAPT.Basics.Operators"><code>ADAPT.Basics.Operators</code></a></li><li><a href="#ADAPT.AbstractAnsatz"><code>ADAPT.AbstractAnsatz</code></a></li><li><a href="#ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any}"><code>ADAPT.AbstractCallback</code></a></li><li><a href="#ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.AbstractCallback</code></a></li><li><a href="#ADAPT.AbstractCallback"><code>ADAPT.AbstractCallback</code></a></li><li><a href="#ADAPT.AdaptProtocol"><code>ADAPT.AdaptProtocol</code></a></li><li><a href="#ADAPT.Basics.Ansatz"><code>ADAPT.Basics.Ansatz</code></a></li><li><a href="#ADAPT.Basics.Ansatz-Tuple{Any, Any}"><code>ADAPT.Basics.Ansatz</code></a></li><li><a href="#ADAPT.Basics.Callbacks.FloorStopper"><code>ADAPT.Basics.Callbacks.FloorStopper</code></a></li><li><a href="#ADAPT.Basics.Callbacks.ParameterPrinter"><code>ADAPT.Basics.Callbacks.ParameterPrinter</code></a></li><li><a href="#ADAPT.Basics.Callbacks.ParameterStopper"><code>ADAPT.Basics.Callbacks.ParameterStopper</code></a></li><li><a href="#ADAPT.Basics.Callbacks.ParameterTracer"><code>ADAPT.Basics.Callbacks.ParameterTracer</code></a></li><li><a href="#ADAPT.Basics.Callbacks.Printer"><code>ADAPT.Basics.Callbacks.Printer</code></a></li><li><a href="#ADAPT.Basics.Callbacks.ScoreStopper"><code>ADAPT.Basics.Callbacks.ScoreStopper</code></a></li><li><a href="#ADAPT.Basics.Callbacks.Serializer"><code>ADAPT.Basics.Callbacks.Serializer</code></a></li><li><a href="#ADAPT.Basics.Callbacks.SlowStopper"><code>ADAPT.Basics.Callbacks.SlowStopper</code></a></li><li><a href="#ADAPT.Basics.Callbacks.Tracer"><code>ADAPT.Basics.Callbacks.Tracer</code></a></li><li><a href="#ADAPT.Basics.OptimOptimizer-Tuple{Symbol}"><code>ADAPT.Basics.OptimOptimizer</code></a></li><li><a href="#ADAPT.Basics.OptimOptimizer"><code>ADAPT.Basics.OptimOptimizer</code></a></li><li><a href="#ADAPT.Basics.VanillaADAPT"><code>ADAPT.Basics.VanillaADAPT</code></a></li><li><a href="#ADAPT.CallbackList"><code>ADAPT.CallbackList</code></a></li><li><a href="#ADAPT.Data"><code>ADAPT.Data</code></a></li><li><a href="#ADAPT.Energy"><code>ADAPT.Energy</code></a></li><li><a href="#ADAPT.EnergyList"><code>ADAPT.EnergyList</code></a></li><li><a href="#ADAPT.Generator"><code>ADAPT.Generator</code></a></li><li><a href="#ADAPT.GeneratorList"><code>ADAPT.GeneratorList</code></a></li><li><a href="#ADAPT.Observable"><code>ADAPT.Observable</code></a></li><li><a href="#ADAPT.OptimizationFreeADAPT.OptimizationFree"><code>ADAPT.OptimizationFreeADAPT.OptimizationFree</code></a></li><li><a href="#ADAPT.OptimizationProtocol"><code>ADAPT.OptimizationProtocol</code></a></li><li><a href="#ADAPT.Parameter"><code>ADAPT.Parameter</code></a></li><li><a href="#ADAPT.ParameterList"><code>ADAPT.ParameterList</code></a></li><li><a href="#ADAPT.QuantumState"><code>ADAPT.QuantumState</code></a></li><li><a href="#ADAPT.Score"><code>ADAPT.Score</code></a></li><li><a href="#ADAPT.ScoreList"><code>ADAPT.ScoreList</code></a></li><li><a href="#ADAPT.Trace"><code>ADAPT.Trace</code></a></li><li><a href="#Base.Matrix-Tuple{ADAPT.OverlapADAPT.Infidelity}"><code>Base.Matrix</code></a></li><li><a href="#Base.Matrix-Tuple{Any, Int64, Any, Number}"><code>Base.Matrix</code></a></li><li><a href="#Base.Matrix-Tuple{Any, Int64, AbstractAnsatz}"><code>Base.Matrix</code></a></li><li><a href="#ADAPT.Basics.MyPauliOperators.cis!-Tuple{AbstractVector, PauliOperators.FixedPhasePauli, Any}"><code>ADAPT.Basics.MyPauliOperators.cis!</code></a></li><li><a href="#ADAPT.Basics.MyPauliOperators.measure_commutator-Tuple{Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Dict{PauliOperators.KetBitString{N}} where N, AbstractVector}}"><code>ADAPT.Basics.MyPauliOperators.measure_commutator</code></a></li><li><a href="#ADAPT.Basics.Operators.hubbard_hamiltonian-Tuple{Int64, Any, Any}"><code>ADAPT.Basics.Operators.hubbard_hamiltonian</code></a></li><li><a href="#ADAPT.Basics.Operators.hubbard_hamiltonian-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any}} where T"><code>ADAPT.Basics.Operators.hubbard_hamiltonian</code></a></li><li><a href="#ADAPT.Basics.Operators.qubitexcitation-Tuple{Int64, Int64, Int64}"><code>ADAPT.Basics.Operators.qubitexcitation</code></a></li><li><a href="#ADAPT.Basics.__make__costate-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N, Any, Dict{PauliOperators.KetBitString{N}} where N}"><code>ADAPT.Basics.__make__costate</code></a></li><li><a href="#ADAPT.Basics.__make__costate-Tuple{Any, Any, Any}"><code>ADAPT.Basics.__make__costate</code></a></li><li><a href="#ADAPT.adapt!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.adapt!</code></a></li><li><a href="#ADAPT.angles-Tuple{AbstractAnsatz}"><code>ADAPT.angles</code></a></li><li><a href="#ADAPT.bind!-Union{Tuple{G}, Tuple{F}, Tuple{AbstractAnsatz{F, G}, AbstractVector{F}}} where {F, G}"><code>ADAPT.bind!</code></a></li><li><a href="#ADAPT.calculate_score-Tuple{AbstractAnsatz, AdaptProtocol, Any, Any, Any}"><code>ADAPT.calculate_score</code></a></li><li><a href="#ADAPT.calculate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.calculate_scores</code></a></li><li><a href="#ADAPT.evaluate-Tuple{Any, Any}"><code>ADAPT.evaluate</code></a></li><li><a href="#ADAPT.evaluate-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.evaluate</code></a></li><li><a href="#ADAPT.evolve_state-Tuple{Any, Number, Any}"><code>ADAPT.evolve_state</code></a></li><li><a href="#ADAPT.evolve_state-Tuple{AbstractAnsatz, Any}"><code>ADAPT.evolve_state</code></a></li><li><a href="#ADAPT.evolve_state!-Tuple{AbstractAnsatz, Any}"><code>ADAPT.evolve_state!</code></a></li><li><a href="#ADAPT.evolve_state!-Tuple{Any, Number, Any}"><code>ADAPT.evolve_state!</code></a></li><li><a href="#ADAPT.evolve_unitary-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary</code></a></li><li><a href="#ADAPT.evolve_unitary-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary</code></a></li><li><a href="#ADAPT.evolve_unitary!-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary!</code></a></li><li><a href="#ADAPT.evolve_unitary!-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary!</code></a></li><li><a href="#ADAPT.gradient-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.gradient</code></a></li><li><a href="#ADAPT.gradient!-Tuple{AbstractVector, AbstractAnsatz, Any, Any}"><code>ADAPT.gradient!</code></a></li><li><a href="#ADAPT.is_converged-Tuple{AbstractAnsatz}"><code>ADAPT.is_converged</code></a></li><li><a href="#ADAPT.is_optimized-Tuple{AbstractAnsatz}"><code>ADAPT.is_optimized</code></a></li><li><a href="#ADAPT.make_costfunction-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_costfunction</code></a></li><li><a href="#ADAPT.make_gradfunction-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_gradfunction</code></a></li><li><a href="#ADAPT.make_gradfunction!-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_gradfunction!</code></a></li><li><a href="#ADAPT.optimize!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.optimize!</code></a></li><li><a href="#ADAPT.partial-Tuple{Int64, AbstractAnsatz, Any, Any}"><code>ADAPT.partial</code></a></li><li><a href="#ADAPT.partial-Tuple{Int64, AbstractAnsatz, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.Pauli, PauliOperators.PauliSum, PauliOperators.ScaledPauli}, Any}"><code>ADAPT.partial</code></a></li><li><a href="#ADAPT.run!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.run!</code></a></li><li><a href="#ADAPT.set_converged!-Tuple{AbstractAnsatz, Bool}"><code>ADAPT.set_converged!</code></a></li><li><a href="#ADAPT.set_optimized!-Tuple{AbstractAnsatz, Bool}"><code>ADAPT.set_optimized!</code></a></li><li><a href="#ADAPT.typeof_energy-Tuple{Any}"><code>ADAPT.typeof_energy</code></a></li><li><a href="#ADAPT.typeof_parameter-Union{Tuple{AbstractAnsatz{F, G}}, Tuple{G}, Tuple{F}} where {F, G}"><code>ADAPT.typeof_parameter</code></a></li><li><a href="#ADAPT.typeof_score-Tuple{AdaptProtocol}"><code>ADAPT.typeof_score</code></a></li><li><a href="#ADAPT.validate-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate</code></a></li><li><a href="#ADAPT.validate_consistency-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_consistency</code></a></li><li><a href="#ADAPT.validate_evaluation-Tuple{Any, Any}"><code>ADAPT.validate_evaluation</code></a></li><li><a href="#ADAPT.validate_evolution-Tuple{Any, Number, Any}"><code>ADAPT.validate_evolution</code></a></li><li><a href="#ADAPT.validate_gradient-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.validate_gradient</code></a></li><li><a href="#ADAPT.validate_runtime-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_runtime</code></a></li><li><a href="#ADAPT.validate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_scores</code></a></li><li><a href="#Base.:*-Union{Tuple{N}, Tuple{PauliOperators.PauliSum{N}, Array{PauliOperators.ScaledPauli{N}, 1}}} where N"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Array{PauliOperators.ScaledPauli{N}, 1}, Dict{PauliOperators.KetBitString{N}, T}}} where {N, T}"><code>Base.:*</code></a></li><li><a href="#Base.adjoint-Tuple{Dict{PauliOperators.KetBitString{N}} where N}"><code>Base.adjoint</code></a></li><li><a href="#Base.adjoint-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N}"><code>Base.adjoint</code></a></li><li><a href="#ADAPT.@runtime-Tuple{Any, Any}"><code>ADAPT.@runtime</code></a></li></ul><h3 id="Core"><a class="docs-heading-anchor" href="#Core">Core</a><a id="Core-1"></a><a class="docs-heading-anchor-permalink" href="#Core" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.AbstractAnsatz" href="#ADAPT.AbstractAnsatz"><code>ADAPT.AbstractAnsatz</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAnsatz{F,G}</code></pre><p>An image of an ADAPT protocol in a frozen state.</p><p>The type is so named because the most basic possible such image     consists of just the generators and parameters of the ansatz thus far selected,     but richer variants of ADAPT will have richer states.</p><p>For example, a version of ADAPT which carries information     on the inverse Hessian across ADAPT iterations     would need to operate on an ansatz type which includes the inverse Hessian.</p><p>Nevertheless, every sub-type of AbstractAnsatz implements the AbstractVector interface,     where elements are pairs <code>(generator =&gt; parameter)</code>.</p><p>So, for example, an ansatz maintaining an inverse Hessian would need     to override <code>push!</code> <code>insert!</code>, etc. to ensure the dimension of the Hessian matches.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: the number type of the parameters (usually <code>Float64</code>)</li><li><code>G</code>: the subtype of <code>Generator</code></li></ul><p><strong>Implementation</strong></p><p>Sub-types must implement the following methods:</p><ul><li><code>__get__generators(::AbstractAnsatz{F,G})::Vector{G}</code></li><li><code>__get__parameters(::AbstractAnsatz{F,G})::Vector{F}</code></li><li><code>__get__optimized(::AbstractAnsatz{F,G})::Ref{Bool}</code></li><li><code>__get__converged(::AbstractAnsatz{F,G})::Ref{Bool}</code></li></ul><p>Each of these is expected to simply retrieve an attribute of the struct. You can call them whatever you&#39;d like, but functionally, here&#39;s what they mean:</p><ul><li><p><code>generators::Vector{G}</code>: the sequence of generators</p></li><li><p><code>parameters::Vector{F}</code>: the corresponding sequence of parameters</p><p>Note that these vectors will be mutated and resized as needed.</p></li><li><p><code>optimized::Ref{Bool}</code>: a flag indicating that the current parameters are optimal</p></li><li><p><code>converged::Ref{Bool}</code>: a flag indicating that the current generators are optimal</p><p>Note that these must be of type <code>Ref</code>, so their values can be toggled as needed.</p></li></ul><p>In addition, there must be a compatible implementation for each of:</p><ul><li><p><code>partial(   index::Int,   ansatz::AbstractAnsatz,   observable::Observable,   reference::QuantumState, )</code></p></li><li><p><code>calculate_score(   ::AbstractAnsatz,   ::AdaptProtocol,   ::Generator,   ::Observable,   ::QuantumState, )::Score</code></p></li><li><p><code>adapt!(   ::AbstractAnsatz,   ::Trace,   ::AdaptProtocol,   ::GeneratorList,   ::Observable,   ::QuantumState,   ::CallbackList, )</code></p></li><li><p><code>optimize!(   ::AbstractAnsatz,   ::Trace,   ::OptimizationProtocol,   ::Observable,   ::QuantumState,   ::CallbackList, )</code></p></li></ul><p>That said, most basic implementations of these methods are defined for abstract ansatze,     so you oughtn&#39;t need to worry about them.</p><p>Please see individual method documentation for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L5-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.AbstractCallback" href="#ADAPT.AbstractCallback"><code>ADAPT.AbstractCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCallback</code></pre><p>A function to be called at each adapt iteration, or vqe iteration, or both.</p><p><strong>Common Examples</strong></p><ol><li>Tracers: update the running <code>trace</code> with information passed in <code>data</code></li><li>Printers: display the information passed in <code>data</code> to the screen or to a file</li><li>Stoppers: flag the ADAPT state as converged, based on some condition</li></ol><p>In particular, the standard way to converge an adapt run is to include a <code>ScoreStopper</code>. Otherwise, the run will keep adding parameters until every score is essentially zero.</p><p>More details can be found in the <code>Callbacks</code> module,     where many standard callbacks are already implemented.</p><p><strong>Implementation</strong></p><p>Callbacks are implemented as callable objects, with two choices of method header     (one for adaptations, one for optimization iterations).</p><ul><li><p><code>(::AbstractCallback)(   ::Data,   ::AbstractAnsatz,   ::Trace,   ::AdaptProtocol,   ::GeneratorList,   ::Observable,   ::QuantumState, )</code></p></li><li><p><code>(::AbstractCallback)(   ::Data,   ::AbstractAnsatz,   ::Trace,   ::OptimizationProtocol,   ::Observable,   ::QuantumState, )</code></p></li></ul><p>If your callback is only meant for adaptations,     simply do not implement the method for optimizations. (Behind the scenes, every <code>AbstractCallback</code> has default implementations for both methods,     which just don&#39;t do anything.)</p><p>Precisely what data is contained within the <code>data</code> depends on the protocol. For example, the <code>ScoreStopper</code> expects to find the key <code>:scores</code>,     whose value is a <code>ScoreList</code>, one score for each pool operator. Generally, the callback should assume <code>data</code> has whatever it needs,     and if it doesn&#39;t, that means this callback is incompatible with the given protocol. That said, see the <code>Callbacks</code> module for some standard choices.</p><p>The callback is free to mutate the <code>ansatz</code>. For example, the <code>ScoreStopper</code> signals a run should end by calling <code>set_converged!</code>. But, if the callback wants to signal the run should end in an UN-converged state,     it should simply return <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L41-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any}" href="#ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.AbstractCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(::AbstractCallback)(
    ::Data,
    ::AbstractAnsatz,
    ::Trace,
    ::AdaptProtocol,
    ::GeneratorList,
    ::Observable,
    ::QuantumState,
)</code></pre><p>Callback for adapt iterations, called immediately prior to the ansatz update.</p><p>Note that the ansatz is already updated in the optimization callback,     but not in the adaptation callback.</p><p><strong>Parameters</strong></p><ul><li>Almost all parameters for the <code>adapt!</code> method. See that method for details.</li><li><code>data</code>: (replaces <code>callbacks</code>) additional calculations the ADAPT method has made   Keys depend on the protocol. See the <code>Callbacks</code> module for some standard choices.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> iff ADAPT should terminate, without updating ansatz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L317-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any}" href="#ADAPT.AbstractCallback-Tuple{Dict{Symbol, Any}, AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any}"><code>ADAPT.AbstractCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(::AbstractCallback)(
    ::Data,
    ::AbstractAnsatz,
    ::Trace,
    ::OptimizationProtocol,
    ::Observable,
    ::QuantumState,
)</code></pre><p>Callback for optimization iterations, called AFTER ansatz update.</p><p>Note that the ansatz is already updated in optimization callback,     but not in the adaptation callback.</p><p><strong>Parameters</strong></p><ul><li>Almost all parameters for the <code>optimize!</code> method. See that method for details.</li><li><code>data</code>: (replaces <code>callbacks</code>) additional calculations the optimization method has made   Keys depend on the protocol. See the <code>Callbacks</code> module for some standard choices.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> iff optimization should terminate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L445-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.AdaptProtocol" href="#ADAPT.AdaptProtocol"><code>ADAPT.AdaptProtocol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptProtocol</code></pre><p>A distinctive protocol for adding new parameters after optimizing an initial ansatz.</p><p><strong>Implementation</strong></p><p>Sub-types must implement the following method:</p><ul><li><code>typeof_parameter(::AbstractAnsatz)::Type{&lt;:Parameter}</code></li></ul><p>In addition, new sub-types probably need to implement:</p><ul><li><p><code>calculate_score(   ::AbstractAnsatz,   ::AdaptProtocol,   ::Generator,   ::Observable,   ::QuantumState, )::Score</code></p></li><li><p><code>adapt!(   ::AbstractAnsatz,   ::Trace,   ::AdaptProtocol,   ::GeneratorList,   ::Observable,   ::QuantumState,   ::CallbackList, )</code></p></li></ul><p>Finally, new sub-types might be able to provide better implementations of:</p><ul><li><code>calculate_scores(   ansatz::AbstractAnsatz,   ADAPT::AdaptProtocol,   pool::GeneratorList,   observable::Observable,   reference::QuantumState, )</code></li></ul><p>For the most part, sub-types should be singleton objects, ie. no attributes. Arbitrary hyperparameters like gradient tolerance should be delegated to callbacks     as much as possible. It&#39;s okay to insist a particular callback always be included with your ADAPT protocol,     so long as you are clear in the documentation. That said, this rule is a &quot;style&quot; guideline, not a contract.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L113-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.CallbackList" href="#ADAPT.CallbackList"><code>ADAPT.CallbackList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CallbackList</code></pre><p>Semantic alias for a vector of callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Data" href="#ADAPT.Data"><code>ADAPT.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Data</code></pre><p>Semantic alias for trace-worthy information from a single adapt or vqe iteration.</p><p>You&#39;ll never actually have to deal with this object     unless you are implementing your own protocol or callback.</p><p>Keys can in principle be any Symbol at all. You can design your own protocols to fill the data,     and your own callbacks to use it. That said, see the <code>Callbacks</code> module for some standard choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Energy" href="#ADAPT.Energy"><code>ADAPT.Energy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Energy</code></pre><p>Semantic alias for the expectation value of an observable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.EnergyList" href="#ADAPT.EnergyList"><code>ADAPT.EnergyList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyList</code></pre><p>Semantic alias for a vector of energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Generator" href="#ADAPT.Generator"><code>ADAPT.Generator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generator</code></pre><p>The Union of any type that could be used as a pool operator.</p><p><strong>Implemented Types</strong></p><p>Any type at all can be used as a generator   if there is a compatible implementation   of the methods listed in the <code>Implementation</code> section.</p><p>The following types have implementations fleshed out in this library already:</p><ul><li><p><code>PauliOperators.Pauli</code>: A single Pauli word</p></li><li><p><code>PauliOperators.ScaledPauli</code>: A single Pauli word, alongside some scaling coefficient</p></li><li><p><code>PauliOperators.PauliSum</code>: A Hermitian operator decomposed into the Pauli basis</p></li><li><p><code>PauliOperators.ScaledPauliVector</code>: Same but with a different internal data structure</p><p>For each of the above,     the generator <code>G</code> generates the unitary <code>exp(-iθG)</code>. Hermiticity in <code>G</code> is not enforced, so be careful when constructing your pool operators.</p></li></ul><p><strong>Implementation</strong></p><p>This list should be extended as new sub-types are implemented.</p><p>New sub-types probably need to implement:</p><ul><li><code>evolve_state!(   ::Generator,   ::Parameter,   ::QuantumState, )</code></li></ul><p>In addition, new sub-types might be able to provide better implementations of:</p><ul><li><code>calculate_scores(   ansatz::AbstractAnsatz,   adapt::AdaptProtocol,   pool::GeneratorList,   observable::Observable,   reference::QuantumState, )</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_objects.jl#L7-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.GeneratorList" href="#ADAPT.GeneratorList"><code>ADAPT.GeneratorList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneratorList</code></pre><p>Semantic alias for a vector of generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_objects.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Observable" href="#ADAPT.Observable"><code>ADAPT.Observable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Observable</code></pre><p>The Union of any type that could define a cost function.</p><p>The type is so named because the typical cost-function is the expecation value     of a Hermitian operator, aka a quantum observable.</p><p><strong>Implemented Types</strong></p><p>Any type at all can be used as a generator   if there is a compatible implementation   of the methods listed in the <code>Implementation</code> section.</p><p>The following types have implementations fleshed out in this library already:</p><ul><li><p><code>PauliOperators.Pauli</code>: A single Pauli word</p></li><li><p><code>PauliOperators.ScaledPauli</code>: A single Pauli word, alongside some scaling coefficient</p></li><li><p><code>PauliOperators.PauliSum</code>: A Hermitian operator decomposed into the Pauli basis</p></li><li><p><code>PauliOperators.ScaledPauliVector</code>: Same but with a different internal data structure</p><p>For each of the above,     the evaluation of <code>H</code> with respect to a quantum state <code>|Ψ⟩</code> is <code>⟨Ψ|H|Ψ⟩</code>.</p></li></ul><p><strong>Implementation</strong></p><p>This list should be extended as new sub-types are implemented.</p><p>Sub-types must implement the following method:</p><ul><li><code>typeof_energy(::Observable)::Type{&lt;:Energy}</code></li></ul><p>In addition, new sub-types probably need to implement:</p><ul><li><code>evaluate(   ::Observable,   ::QuantumState, )::Energy</code></li></ul><p>Finally, new sub-types might be able to provide better implementations of:</p><ul><li><p><code>gradient!(   ansatz::AbstractAnsatz,   observable::Observable,   reference::QuantumState, )</code></p></li><li><p><code>calculate_scores(   ansatz::AbstractAnsatz,   adapt::AdaptProtocol,   pool::GeneratorList,   observable::Observable,   reference::QuantumState, )</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_objects.jl#L67-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.OptimizationProtocol" href="#ADAPT.OptimizationProtocol"><code>ADAPT.OptimizationProtocol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptimizationProtocol</code></pre><p>A distinctive protocol for refining parameters in an ansatz.</p><p><strong>Implementation</strong></p><p>Sub-types must implement the following method:</p><ul><li><code>optimize!(   ::AbstractAnsatz,   ::Trace,   ::OptimizationProtocol,   ::Observable,   ::QuantumState,   ::CallbackList, )::Bool</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L356-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Parameter" href="#ADAPT.Parameter"><code>ADAPT.Parameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Parameter</code></pre><p>Semantic alias for the coefficient of a generator in an ansatz.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.ParameterList" href="#ADAPT.ParameterList"><code>ADAPT.ParameterList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterList</code></pre><p>Semantic alias for a vector of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.QuantumState" href="#ADAPT.QuantumState"><code>ADAPT.QuantumState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumState</code></pre><p>The Union of any type that could define a quantum state.</p><p><strong>Implemented Types</strong></p><p>Any type at all can be used as a generator   if there is a compatible implementation   of the methods listed in the <code>Implementation</code> section.</p><p>The following types have implementations fleshed out in this library already:</p><ul><li><p><code>Vector{&lt;:Complex}</code>: A dense statevector in the computational basis</p></li><li><p><code>PauliOperators.SparseKetBasis</code>:</p><p>A dict mapping individual kets (<code>PauliOperators.KetBitString</code>) to their coefficients.</p></li></ul><p><strong>Implementation</strong></p><p>This list should be extended as new sub-types are implemented.</p><p>There must be a compatible implementation for each of:</p><ul><li><p><code>evolve_state!(   ::Generator,   ::Parameter,   ::QuantumState, )</code></p></li><li><p><code>evaluate(   ::Observable,   ::QuantumState, )::Energy</code></p></li><li><p><code>gradient!(   index::Int,   ansatz::AbstractAnsatz,   observable::Observable,   reference::QuantumState, )</code></p></li><li><p><code>calculate_scores(   ansatz::AbstractAnsatz,   adapt::AdaptProtocol,   pool::GeneratorList,   observable::Observable,   reference::QuantumState, )</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_objects.jl#L144-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Score" href="#ADAPT.Score"><code>ADAPT.Score</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Score</code></pre><p>Semantic alias for the importance-factor of a pool operator,     eg. the expecation value of its commutator with an observable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.ScoreList" href="#ADAPT.ScoreList"><code>ADAPT.ScoreList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScoreList</code></pre><p>Semantic alias for a vector of scores.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__number_aliases.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Trace" href="#ADAPT.Trace"><code>ADAPT.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Trace</code></pre><p>Semantic alias for a compact record of the entire ADAPT run.</p><p>The <code>adapt!</code>, <code>optimize!</code>, and <code>run!</code> functions require a <code>Trace</code> object,     which will be mutated throughout according to callbacks. Initialize an empty trace object by <code>trace = Trace()</code>.</p><p>Keys can in principle be any Symbol at all. You can design your own protocols to fill the data,     and your own callbacks to use it. That said, see the <code>Callbacks</code> module for some standard choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{Any, Int64, AbstractAnsatz}" href="#Base.Matrix-Tuple{Any, Int64, AbstractAnsatz}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.Matrix([F,] N::Int, ansatz::AbstractAnsatz)</code></pre><p>Construct the unitary matrix representation of the action of an ansatz.</p><p><strong>Parameters</strong></p><ul><li><code>F</code>: float type; the resulting matrix will be of type Matrix{Complex{F}}</li><li><code>N</code>: size of Hilbert space (ie. the number of rows in the matrix)</li><li><code>ansatz</code>: the ansatz to be represented</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{Any, Int64, Any, Number}" href="#Base.Matrix-Tuple{Any, Int64, Any, Number}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.Matrix([F,] N::Int, G::Generator, θ::Parameter)</code></pre><p>Construct the unitary matrix representation of <span>$exp(-iθG)$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>F</code>: float type; the resulting matrix will be of type Matrix{Complex{F}}</li><li><code>N</code>: size of Hilbert space (ie. the number of rows in the matrix)</li><li><code>G</code>: the generator of the matrix</li><li><code>θ</code>: a scalar coefficient multiplying the generator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.adapt!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}" href="#ADAPT.adapt!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.adapt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt!(
    ::AbstractAnsatz,
    ::Trace,
    ::AdaptProtocol,
    ::GeneratorList,
    ::Observable,
    ::QuantumState,
    ::CallbackList,
)</code></pre><p>Update an ansatz with a new generator(s) according to a given ADAPT protocol.</p><p>Typically, each call to this function will select a single generator         whose score has the largest magnitude,     but richer variants of ADAPT will have richer behavior.</p><p>For example, an implementation of Tetris ADAPT would add multiple generators,     based on both the score and the &quot;disjointness&quot; of the generators     (which is something that implementation would have to define).</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>trace</code>: a history of the ADAPT run thus far</li><li><code>ADAPT</code>: the ADAPT protocol</li><li><code>pool</code>: the list of generators to consider adding to the ansatz</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li><li><code>callbacks</code>: a list of functions to be called just prior to updating the ansatz</li></ul><p><strong>Returns</strong></p><ul><li>a <code>Bool</code>, indicating whether or not an adaptation was made</li></ul><p><strong>Implementation</strong></p><p>Any implementation of this method must be careful to obey the following contract:</p><ol><li><p>If your ADAPT protocol decides the ansatz is already converged,      call <code>set_converged!(ansatz, true)</code> and return <code>false</code>,      without calling any callbacks.</p></li><li><p>Fill up a <code>data</code> dict with the expensive calculations you have to make anyway. See the default implementation for a minimal selection of data to include.</p></li><li><p>BEFORE you actually update the ansatz,      call each callback in succession, passing it the <code>data</code> dict. If any callback returns <code>true</code>, return <code>false</code> without calling any more callbacks,      and without updating the <code>ansatz</code>.</p></li><li><p>After all callbacks have been completed,  update the ansatz, call <code>set_optimized!(ansatz, false)</code>, and return <code>true</code>.</p></li></ol><p>Standard operating procedure is to let callbacks do all the updates to <code>trace</code>. Thus, implementations of this method should normally ignore <code>trace</code> entirely     (except in passing it along to the callbacks). That said, this rule is a &quot;style&quot; guideline, not a contract.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L249-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.angles-Tuple{AbstractAnsatz}" href="#ADAPT.angles-Tuple{AbstractAnsatz}"><code>ADAPT.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(::AbstractAnsatz)</code></pre><p>Fetch all parameters in the ansatz as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.bind!-Union{Tuple{G}, Tuple{F}, Tuple{AbstractAnsatz{F, G}, AbstractVector{F}}} where {F, G}" href="#ADAPT.bind!-Union{Tuple{G}, Tuple{F}, Tuple{AbstractAnsatz{F, G}, AbstractVector{F}}} where {F, G}"><code>ADAPT.bind!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bind!(::AbstractAnsatz, ::ParameterList)</code></pre><p>Replace all parameters in the ansatz.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.calculate_score-Tuple{AbstractAnsatz, AdaptProtocol, Any, Any, Any}" href="#ADAPT.calculate_score-Tuple{AbstractAnsatz, AdaptProtocol, Any, Any, Any}"><code>ADAPT.calculate_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_score(
    ansatz::AbstractAnsatz,
    ADAPT::AdaptProtocol,
    generator::Generator,
    H::Observable,
    ψ0::QuantumState,
)</code></pre><p>Calculate an &quot;importance&quot; score for a generator, with respect to a particular ADAPT state.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>ADAPT</code>: the ADAPT protocol. Different protocols may have different scoring strategies.</li><li><code>generator</code>: the generator to be scored</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>score</code>: a scalar number, whose type is <code>typeof_score(ADAPT)</code></li></ul><p><strong>Implementation</strong></p><p>In addition to implementing this method (which is mandatory),     strongly consider over-riding <code>calculate_scores</code> also,     to take advantage of compact measurement protocols,     or simply the fact that you should only need to evolve your reference state once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L174-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.calculate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}" href="#ADAPT.calculate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.calculate_scores</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_scores(
    ansatz::AbstractAnsatz,
    ADAPT::AdaptProtocol,
    pool::GeneratorList,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>Calculate a vector of scores for all generators in the pool.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>ADAPT</code>: the ADAPT protocol. Different protocols may have different scoring strategies.</li><li><code>pool</code>: the list of generators to be scored</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>scores</code>: a vector whose elements are of type <code>typeof_score(ADAPT)</code>.   <code>scores[i]</code> is the score for the generator <code>pool[i]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L211-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evaluate-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.evaluate-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(
    ansatz::AbstractAnsatz,
    H::Observable,
    ψ0::QuantumState,
)</code></pre><p>Evaluate a cost-function with respect to a particular ADAPT state.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>energy</code>: a scalar number, whose type is <code>typeof_energy(observable)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L91-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evaluate-Tuple{Any, Any}" href="#ADAPT.evaluate-Tuple{Any, Any}"><code>ADAPT.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(
    H::Observable,
    Ψ::QuantumState,
)</code></pre><p>Evaluate a cost-function with respect to a particular quantum state.</p><p><strong>Parameters</strong></p><ul><li><code>H</code>: the object defining the cost-function</li><li><code>Ψ</code>: the quantum state</li></ul><p><strong>Returns</strong></p><ul><li><code>energy</code>: a scalar number, whose type is <code>typeof_energy(observable)</code></li></ul><p><strong>Implementation</strong></p><p>Typically, the &quot;cost-function&quot; is the expectation value <code>⟨Ψ|H|Ψ⟩</code>,     but different <code>Observable</code> types could have different definitions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L118-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_state!-Tuple{AbstractAnsatz, Any}" href="#ADAPT.evolve_state!-Tuple{AbstractAnsatz, Any}"><code>ADAPT.evolve_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_state!(
    ansatz::AbstractAnsatz,
    state::QuantumState,
)</code></pre><p>Apply an ansatz to the given quantum state, mutating and returning the state.</p><p>By default, generators with a lower index are applied to the state earlier. This means that the equation for |Ψ⟩ would list out generators in reverse order. Specific implementations of ansatze may override this behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L43-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_state!-Tuple{Any, Number, Any}" href="#ADAPT.evolve_state!-Tuple{Any, Number, Any}"><code>ADAPT.evolve_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_state!(
    G::Generator,
    θ::Parameter,
    ψ::QuantumState,
)</code></pre><p>Rotate a quantum state <code>ψ</code> by an amount <code>x</code> about the axis defined by <code>G</code>,     mutating and returning <code>ψ</code>.</p><p><strong>Implementation</strong></p><p>Typically, the &quot;rotation&quot; is the unitary operator <code>exp(-iθG)</code>,     but different <code>Generator</code> types could have different effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_state-Tuple{AbstractAnsatz, Any}" href="#ADAPT.evolve_state-Tuple{AbstractAnsatz, Any}"><code>ADAPT.evolve_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_state(
    ansatz::AbstractAnsatz,
    reference::QuantumState,
)</code></pre><p>Calculate the quantum state resulting from applying an ansatz to a given reference state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_state-Tuple{Any, Number, Any}" href="#ADAPT.evolve_state-Tuple{Any, Number, Any}"><code>ADAPT.evolve_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_state(
    G::Generator,
    θ::Parameter,
    ψ::QuantumState,
)</code></pre><p>Calculate the quantum state rotating <code>ψ</code> by an amount <code>x</code> about the axis defined by <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_unitary!-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}" href="#ADAPT.evolve_unitary!-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_unitary!(
    ansatz::AbstractAnsatz,
    unitary::AbstractMatrix{&lt;:Complex},
)</code></pre><p>Extend a unitary by applying each generator in the ansatz (on the left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_unitary!-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}" href="#ADAPT.evolve_unitary!-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_unitary!(
    G::Generator,
    θ::Parameter,
    unitary::AbstractMatrix{&lt;:Complex},
)</code></pre><p>Extend a unitary by applying a single generator (on the left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_unitary-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}" href="#ADAPT.evolve_unitary-Tuple{AbstractAnsatz, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_state(
    ansatz::AbstractAnsatz,
    unitary::AbstractMatrix{&lt;:Complex},
)</code></pre><p>Calculate the matrix extending the given unitary by an ansatz (on the left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.evolve_unitary-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}" href="#ADAPT.evolve_unitary-Tuple{Any, Number, AbstractMatrix{&lt;:Complex}}"><code>ADAPT.evolve_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve_unitary(
    G::Generator,
    θ::Parameter,
    unitary::AbstractMatrix{&lt;:Complex},
)</code></pre><p>Calculate the matrix extending the given unitary by a single generator (on the left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__matrix_functions.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.gradient!-Tuple{AbstractVector, AbstractAnsatz, Any, Any}" href="#ADAPT.gradient!-Tuple{AbstractVector, AbstractAnsatz, Any, Any}"><code>ADAPT.gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient!(
    result::AbstractVector,
    ansatz::AbstractAnsatz,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>Fill a vector of partial derivatives with respect to each parameter in the ansatz.</p><p><strong>Parameters</strong></p><ul><li><code>result</code>: vector which will contain the gradient after calling this function</li><li><code>ansatz</code>: the ADAPT state</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L211-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.gradient-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.gradient-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(
    ansatz::AbstractAnsatz,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>Construct a vector of partial derivatives with respect to each parameter in the ansatz.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li>a vector of type <code>typeof_energy(observable)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.is_converged-Tuple{AbstractAnsatz}" href="#ADAPT.is_converged-Tuple{AbstractAnsatz}"><code>ADAPT.is_converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_converged(::AbstractAnsatz)</code></pre><p>Check whether the sequence of generators in this ansatz are flagged as optimal.</p><p>Note that this is a state variable in its own right;     its value is independent of the actual generators themselves,     but depends on all the protocols and callbacks     which brought the ansatz to its current state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.is_optimized-Tuple{AbstractAnsatz}" href="#ADAPT.is_optimized-Tuple{AbstractAnsatz}"><code>ADAPT.is_optimized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_optimized(::AbstractAnsatz)</code></pre><p>Check whether the ansatz parameters are flagged as optimal.</p><p>Note that this is a state variable in its own right;     its value is independent of the actual parameters themselves,     but depends on all the protocols and callbacks     which brought the ansatz to its current state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L132-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.make_costfunction-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.make_costfunction-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_costfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_costfunction(
    ansatz::ADAPT.AbstractAnsatz,
    observable::ADAPT.Observable,
    reference::ADAPT.QuantumState,
)</code></pre><p>Construct a single-parameter cost-function f(x), where x is a parameter vector.</p><p>Note that calling f does <em>not</em> change the state of the ansatz     (although actually it does temporarily, so this function is not thread-safe).</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>observable</code>: the object defining the cost-function</li><li><code>reference</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>fn</code> a callable function <code>f(x)</code> where <code>x</code> is a vector of angles compatible with <code>ansatz</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L246-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.make_gradfunction!-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.make_gradfunction!-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_gradfunction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_gradfunction!(
    ansatz::ADAPT.AbstractAnsatz,
    observable::ADAPT.Observable,
    reference::ADAPT.QuantumState,
)</code></pre><p>Construct a mutating gradient function g!(∇f, x), where x is a parameter vector.</p><p>Using this in place of <code>make_gradfunction</code> for optimization     will tend to significantly reduce memory allocations.</p><p>Note that calling g! does <em>not</em> change the state of the ansatz     (although actually it does temporarily, so this function is not thread-safe).</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>observable</code>: the object defining the cost-function</li><li><code>reference</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>g!</code> a callable function <code>g!(∇f,x)</code><ul><li><code>∇f</code> and <code>x</code> are vectors of angles compatible with <code>ansatz</code>. The first argument <code>∇f</code> is used to store the result; its initial values are ignored.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L316-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.make_gradfunction-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.make_gradfunction-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.make_gradfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_gradfunction(
    ansatz::ADAPT.AbstractAnsatz,
    observable::ADAPT.Observable,
    reference::ADAPT.QuantumState,
)</code></pre><p>Construct a single-parameter gradient function g(x), where x is a parameter vector.</p><p>Note that calling g does <em>not</em> change the state of the ansatz     (although actually it does temporarily, so this function is not thread-safe).</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>observable</code>: the object defining the cost-function</li><li><code>reference</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li><code>gd</code> a callable function <code>gd(x)</code> where <code>x</code> is a vector of angles compatible with <code>ansatz</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L282-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.optimize!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any, AbstractVector{&lt;:AbstractCallback}}" href="#ADAPT.optimize!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, OptimizationProtocol, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize!(
    ansatz::AbstractAnsatz,
    trace::Trace,
    VQE::OptimizationProtocol,
    H::Observable,
    ψ0::QuantumState,
    callbacks::CallbackList,
)</code></pre><p>Update the parameters of an ansatz according to a given optimization protocol.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>trace</code>: a history of the ADAPT run thus far</li><li><code>VQE</code>: the optimization protocol (it doesn&#39;t have to be a VQE ^_^)</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li><li><code>callbacks</code>: a list of functions to be called just prior to updating the ansatz</li></ul><p><strong>Implementation</strong></p><p>Callbacks must be called in each &quot;iteration&quot;. The optimization protocol is free to decide what an &quot;iteration&quot; is,     but it should generally correspond to &quot;any time the ansatz is changed&quot;. That&#39;s not a hard-fast rule, though -     for example, it doesn&#39;t necessarily make sense to call the callbacks     for each function evaluation in a linesearch.</p><p>Any implementation of this method must be careful to obey the following contract:</p><ol><li><p>In each iteration, update the ansatz parameters and      do whatever calculations you need to do. Fill up a <code>data</code> dict with as much information as possible. See the <code>Callbacks</code> module for some standard choices.</p></li><li><p>Call each callback in succession, passing it the <code>data</code> dict. If any callback returns <code>true</code>, terminate without calling any more callbacks,      and discontinue the optimization.</p></li><li><p>After calling all callbacks, check if the ansatz has been flagged as optimized. If so, discontinue the optimization.</p></li><li><p>If the optimization protocol terminates successfully without interruption by callbacks,      call <code>set_optimized!(ansatz, true)</code>. Be careful to ensure the ansatz parameters actually are the ones found by the optimizer!</p></li></ol><p>Standard operating procedure is to let callbacks do all the updates to <code>trace</code>. Thus, implementations of this method should normally ignore <code>trace</code> entirely     (except in passing it along to the callbacks). That said, this rule is a &quot;style&quot; guideline, not a contract.</p><p>The return type of this method is intentionally unspecified,     so that implementations can return something helpful for debugging,     eg. an <code>Optim</code> result object. If the callbacks interrupt your optimization,     it may be worthwhile to check if they flagged the <code>ansatz</code> as converged,     and modify this return object accordingly if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L376-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.partial-Tuple{Int64, AbstractAnsatz, Any, Any}" href="#ADAPT.partial-Tuple{Int64, AbstractAnsatz, Any, Any}"><code>ADAPT.partial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial(
    index::Int,
    ansatz::AbstractAnsatz,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>The partial derivative of a cost-function with respect to the i-th parameter in an ansatz.</p><p><strong>Parameters</strong></p><ul><li><code>index</code>: the index of the parameter to calculate within <code>ansatz</code></li><li><code>ansatz</code>: the ADAPT state</li><li><code>observable</code>: the object defining the cost-function</li><li><code>reference</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li>a number of type <code>typeof_energy(observable)</code>.</li></ul><p><strong>Implementation</strong></p><p>Typically, generators apply a unitary rotation,     so the partial consists of a partial evolution up to the indexed generator,     then a &quot;kick&quot; from the generator itself, then a final evolution,     and a braket with the observable. But, different ansatze may have a different procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_functions.jl#L145-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.run!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}" href="#ADAPT.run!-Tuple{AbstractAnsatz, Dict{Symbol, Any}, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any, AbstractVector{&lt;:AbstractCallback}}"><code>ADAPT.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(
    ansatz::AbstractAnsatz,
    trace::Trace,
    ADAPT::AdaptProtocol,
    VQE::OptimizationProtocol,
    pool::GeneratorList,
    H::Observable,
    ψ0::QuantumState,
    callbacks::CallbackList,
)</code></pre><p>Loop between optimization and adaptation until convergence.</p><p>The <code>ansatz</code> and <code>trace</code> are mutated throughout,     so that if the user runs this method in a REPL,     she can terminate it (eg. by <code>Ctrl+C</code>) after however long,     and still have meaningful results.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz</code>: the ADAPT state</li><li><code>trace</code>: a history of the ADAPT run thus far</li><li><code>ADAPT</code>: the ADAPT protocol</li><li><code>VQE</code>: the optimization protocol (it doesn&#39;t have to be a VQE ^_^)</li><li><code>pool</code>: the list of generators to consider adding to the ansatz</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li><li><code>callbacks</code>: a list of functions to be called just prior to updating the ansatz</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> iff the ansatz is converged, with respect to the given protocols and callbacks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L483-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.set_converged!-Tuple{AbstractAnsatz, Bool}" href="#ADAPT.set_converged!-Tuple{AbstractAnsatz, Bool}"><code>ADAPT.set_converged!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_converged!(::AbstractAnsatz, ::Bool)</code></pre><p>Flag the sequence of generators in this ansatz as optimal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.set_optimized!-Tuple{AbstractAnsatz, Bool}" href="#ADAPT.set_optimized!-Tuple{AbstractAnsatz, Bool}"><code>ADAPT.set_optimized!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_optimized!(::AbstractAnsatz, ::Bool)</code></pre><p>Flag the ansatz parameters as optimal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.typeof_energy-Tuple{Any}" href="#ADAPT.typeof_energy-Tuple{Any}"><code>ADAPT.typeof_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typeof_energy(::Observable)</code></pre><p>The number type of a cost-function.</p><p>The method is so named because the typical cost-function is the expecation value     of a Hamiltonian, aka an energy.</p><p><strong>Implementation</strong></p><p>Usually a sub-type of <code>AbstractFloat</code>, and probably just about always <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__quantum_objects.jl#L127-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.typeof_parameter-Union{Tuple{AbstractAnsatz{F, G}}, Tuple{G}, Tuple{F}} where {F, G}" href="#ADAPT.typeof_parameter-Union{Tuple{AbstractAnsatz{F, G}}, Tuple{G}, Tuple{F}} where {F, G}"><code>ADAPT.typeof_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typeof_parameter(::AbstractAnsatz)</code></pre><p>The number type of the variational parameters in this ansatz.</p><p>I think this will always be a sub-type of <code>AbstractFloat</code>,     and almost always <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__ansatz.jl#L121-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.typeof_score-Tuple{AdaptProtocol}" href="#ADAPT.typeof_score-Tuple{AdaptProtocol}"><code>ADAPT.typeof_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typeof_score(::AdaptProtocol)</code></pre><p>The number type of the score for each pool operator.</p><p><strong>Implementation</strong></p><p>Usually a sub-type of <code>AbstractFloat</code>, and probably just about always <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__protocols.jl#L162-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}" href="#ADAPT.validate-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate(
    ansatz::AbstractAnsatz,
    adapt::AdaptProtocol,
    vqe::OptimizationProtocol,
    pool::GeneratorList,
    observable::Observable,
    reference::QuantumState;
    kwargs...
)</code></pre><p>Validate that ADAPT will work correctly with the given types.</p><p>It actually <em>runs</em> ADAPT,     so ensure your pool and observable are as simple as the types allow.</p><p>The mandatory arguments are exactly those found in the <code>run!</code> method,     except there is no trace.</p><p><strong>Keyword Arguments</strong></p><ul><li>label: the name of the test-set (useful when validating more than one set of types).</li><li>tolerance: the default tolerance for numerical tests</li><li>evolution: special tolerance for the evolution test, or <code>nothing</code> to skip</li><li>evaluation: special tolerance for the evaluation test, or <code>nothing</code> to skip</li><li>gradient: special tolerance for the gradient test, or <code>nothing</code> to skip</li><li>scores: special tolerance for the scores test, or <code>nothing</code> to skip</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_consistency-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}" href="#ADAPT.validate_consistency-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_consistency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_consistency(
    ansatz::AbstractAnsatz,
    adapt::AdaptProtocol,
    pool::GeneratorList,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>Check that every core ADAPT function is internally consistent     (ie. different versions of the same function give consistent results).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L234-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_evaluation-Tuple{Any, Any}" href="#ADAPT.validate_evaluation-Tuple{Any, Any}"><code>ADAPT.validate_evaluation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_evaluation(
    observable::Observable,
    reference::QuantumState;
    tolerance=1e-10,
)</code></pre><p>Check that observable evaluation matches brute-force matrix-vector results.</p><p>The difference between core ADAPT and brute-force     must have an absolute value within <code>tolerance</code>.</p><p>This function requires the following constructors to be defined:</p><ul><li>Matrix(::Observable)</li><li>Vector(::QuantumState)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L411-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_evolution-Tuple{Any, Number, Any}" href="#ADAPT.validate_evolution-Tuple{Any, Number, Any}"><code>ADAPT.validate_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_evolution(
    generator::Generator,
    angle::Parameter,
    reference::QuantumState;
    tolerance=1e-10,
)</code></pre><p>Check that generator evolution matches brute-force matrix-vector results.</p><p>The difference vector between core ADAPT and brute-force     must have a norm within <code>tolerance</code>.</p><p>This function requires the following constructors to be defined:</p><ul><li>Matrix(::Generator)</li><li>Vector(::QuantumState)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L366-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_gradient-Tuple{AbstractAnsatz, Any, Any}" href="#ADAPT.validate_gradient-Tuple{AbstractAnsatz, Any, Any}"><code>ADAPT.validate_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_gradient(
    ansatz::AbstractAnsatz,
    observable::Observable,
    reference::QuantumState;
    tolerance=1e-10,
)</code></pre><p>Check that the gradient function matches the finite difference.</p><p>The difference vector between core ADAPT and brute-force     must have a norm within <code>tolerance</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L451-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_runtime-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}" href="#ADAPT.validate_runtime-Tuple{AbstractAnsatz, AdaptProtocol, OptimizationProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_runtime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_runtime(
    ansatz::AbstractAnsatz,
    adapt::AdaptProtocol,
    vqe::OptimizationProtocol,
    pool::GeneratorList,
    observable::Observable,
    reference::QuantumState;
    verbose=true,
)</code></pre><p>Check that every core ADAPT function can run for the given types.</p><p>If <code>verbose</code> is true, this method also explicilty @time&#39;s everything,     to catch any super-obvious memory leaks when called manually.</p><p>Note that this <em>will</em> run ADAPT for one iteration,     so ensure your pool and observable are as simple as the types allow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L124-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.validate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}" href="#ADAPT.validate_scores-Tuple{AbstractAnsatz, AdaptProtocol, AbstractVector, Any, Any}"><code>ADAPT.validate_scores</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_score(
    ansatz::AbstractAnsatz,
    adapt::AdaptProtocol,
    pool::GeneratorList,
    observable::Observable,
    reference::QuantumState;
    tolerance=1e-10,
)</code></pre><p>Check that the score for each pool operator matches     the partial for that pool operator when added to a candidate ansatz.</p><p>Of course this only makes sense when the score is the gradient,     which depends on the ADAPT protocol. But this is a common-enough choice to justify a standard method. Other ADAPT protocols may override this method, if desired.</p><p>The difference vector between core ADAPT and brute-force     must have a norm within <code>tolerance</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L497-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.@runtime-Tuple{Any, Any}" href="#ADAPT.@runtime-Tuple{Any, Any}"><code>ADAPT.@runtime</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@runtime do_time, ex
@runtime(do_time, ex)</code></pre><p>A macro to check that an expression evaluates without error,     optionally including an explicit test for runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/core/__validation.jl#L102-L108">source</a></section></article><h3 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Ansatz" href="#ADAPT.Basics.Ansatz"><code>ADAPT.Basics.Ansatz</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ansatz{F&lt;:Parameter,G&lt;:Generator}(
    parameters::Vector{F},
    generators::Vector{G},
    optimized::Bool,
    converged::Bool,
)</code></pre><p>A minimal ADAPT state.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: the number type for the parameters (usually <code>Float64</code> is appropriate.)</li><li><code>G</code>: the generator type. Any type will do, but it&#39;s best to be specific.</li></ul><p><strong>Parameter</strong></p><ul><li><code>parameters</code>: list of current parameters</li><li><code>generators</code>: list of current generators</li><li><code>optimized</code>: whether the current parameters are flagged as optimal</li><li><code>converged</code>: whether the current generators are flagged as converged</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Ansatz.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Ansatz-Tuple{Any, Any}" href="#ADAPT.Basics.Ansatz-Tuple{Any, Any}"><code>ADAPT.Basics.Ansatz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ansatz(F, G)</code></pre><p>Convenience constructor for initializing an empty ansatz.</p><p><strong>Parameters</strong></p><ul><li>the parameter type OR an instance of that type OR a vector whose elements are that type</li><li>the generator type OR an instance of that type OR a vector whose elements are that type</li></ul><p>The easiest way to use this constructor is probably to prepare your generator pool first,     then call <code>Ansatz(Float64, pool)</code>. But please note, the ansatz is always initialized as empty,     even though you&#39;ve passed a list of generators in the constructor!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Ansatz.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.OptimOptimizer" href="#ADAPT.Basics.OptimOptimizer"><code>ADAPT.Basics.OptimOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptimOptimizer(method, options)</code></pre><p><strong>Parameters</strong></p><ul><li><code>method</code>: an optimizer object from the <code>Optim</code> package</li><li><code>options</code>: an options object from the <code>Optim</code> package</li></ul><p>IMPORTANT: the <code>callback</code> attribute of <code>options</code> will be generated automatically         whenever <code>ADAPT.optimize!</code> is called, to insert dynamic callbacks.     If you provide your own callback in <code>options</code>, it will be ignored.     Use the <code>ADAPT.Callback</code> framework to gain extra behavior throughout optimization.     If this framework does not meet your needs,         you&#39;ll need to implement your own <code>OptimizationProtocol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/OptimOptimizer.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.OptimOptimizer-Tuple{Symbol}" href="#ADAPT.Basics.OptimOptimizer-Tuple{Symbol}"><code>ADAPT.Basics.OptimOptimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimOptimizer(method::Symbol; options...)</code></pre><p>A convenience constructor to create <code>OptimOptimizers</code> without referring to <code>Optim</code>.</p><p><strong>Parameters</strong></p><ul><li><code>method</code>: a symbol-ization of the <code>Optim</code> method</li></ul><p><strong>Kewyord Arguments</strong></p><p>You can pass any keyword argument accepted either by     your <code>Optim</code> method&#39;s constructor, or by that of <code>Optim.Options</code>. If you try to pass a <code>callback</code> keyword argument, it will be ignored (see above).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/OptimOptimizer.jl#L25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.VanillaADAPT" href="#ADAPT.Basics.VanillaADAPT"><code>ADAPT.Basics.VanillaADAPT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VanillaADAPT</code></pre><p>Score pool operators by their initial gradients if they were to be appended to the pool. Equivalently, score pool operators by the expectation value     of the commutator of the pool operator with the observable.</p><p>This protocol is defined for when the pool operators and the observable are AbstractPaulis. Note that fermionic operators are perfectly well-represented with AbstractPaulis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/VanillaADAPT.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.__make__costate-Tuple{Any, Any, Any}" href="#ADAPT.Basics.__make__costate-Tuple{Any, Any, Any}"><code>ADAPT.Basics.__make__costate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">__make__costate(G, x, Ψ)</code></pre><p>Compute ∂/∂x exp(ixG) |ψ⟩.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/pauli_plugin.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.__make__costate-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N, Any, Dict{PauliOperators.KetBitString{N}} where N}" href="#ADAPT.Basics.__make__costate-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N, Any, Dict{PauliOperators.KetBitString{N}} where N}"><code>ADAPT.Basics.__make__costate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">__make__costate(G::ScaledPauliVector, x, Ψ)</code></pre><p>Compute ∂/∂x exp(ixG) |ψ⟩.</p><p>Default implementation just applies -iG to Ψ then evolves. That&#39;s fine as long as the evolution is exact. But evolution is not exact if <code>G</code> is a <code>ScaledPauliVector</code> containing non-commuting terms. In such a case, the co-state must be more complicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/pauli_plugin.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.partial-Tuple{Int64, AbstractAnsatz, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.Pauli, PauliOperators.PauliSum, PauliOperators.ScaledPauli}, Any}" href="#ADAPT.partial-Tuple{Int64, AbstractAnsatz, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.Pauli, PauliOperators.PauliSum, PauliOperators.ScaledPauli}, Any}"><code>ADAPT.partial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial(
    index::Int,
    ansatz::AbstractAnsatz,
    observable::Observable,
    reference::QuantumState,
)</code></pre><p>The partial derivative of a cost-function with respect to the i-th parameter in an ansatz.</p><p>The ansatz is assumed to apply a unitary rotation <code>exp(-iθG)</code>,     where <code>G</code> is the (Hermitian) generator,     and generators with a lower index are applied to the state earlier. Ansatz sub-types may change both behaviors.</p><p><strong>Parameters</strong></p><ul><li><code>index</code>: the index of the parameter to calculate within <code>ansatz</code></li><li><code>ansatz</code>: the ADAPT state</li><li><code>H</code>: the object defining the cost-function</li><li><code>ψ0</code>: an initial quantum state which the <code>ansatz</code> operates on</li></ul><p><strong>Returns</strong></p><ul><li>a number of type <code>typeof_energy(observable)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/pauli_plugin.jl#L89-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks" href="#ADAPT.Basics.Callbacks"><code>ADAPT.Basics.Callbacks</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Callbacks</code></pre><p>A suite of basic callbacks for essential functionality.</p><p><strong>Explanation</strong></p><p>The final argument of the <code>adapt!</code>, <code>optimize!</code> and <code>run!</code> methods     calls for a vector of <code>Callbacks</code>. These are callable objects extending behavior at each iteration or adaptation     (or both; see the <code>AbstractCallback</code> type documentation for more details).</p><p>The callback is passed a <code>data</code> object     (aka. a <code>Dict</code> where the keys are <code>Symbols</code> like <code>:energy</code> or <code>:scores</code>),     in addition to the ADAPT state and all the quantum objects. Callbacks may be as simple as displaying the <code>data</code>,     or as involved as carefully modifying the quantum objects to satsify some constraint.</p><p>Each callback in this module can be categorized as one of the following:</p><ol><li>Tracers: update the running <code>trace</code> with information passed in <code>data</code></li><li>Printers: display the information passed in <code>data</code> to the screen or to a file</li><li>Stoppers: flag the ADAPT state as converged, based on some condition</li></ol><p>In particular, Stoppers are the primary means of establishing convergence in Vanilla ADAPT. They do this by flagging the ADAPT state as converged,     which signals to the <code>run!</code> function that it can stop looping once this round is done. Alternatively, though none of the basic callbacks in this module do so,     you amy implement a callback that returns <code>true</code> based on some condition. This signals an instant termination, regardless of convergence.</p><p>Just to reiterate, Stoppers are the <em>primary means of establishing convergence</em>. If you don&#39;t include any callbacks, the <code>run!</code> call may not terminate this century!</p><p><strong>Callback Order</strong></p><p>Callback order matters. Using the callbacks in this module, I recommend the order listed above     (Tracers, then Printers, then Stoppers).</p><p>The first callback in the list gets dibs on mutating the trace or the ADAPT state,     which could change the behavior of subsequent callbacks. For example, the basic <code>Printer</code> inspects the trace to infer the current iteration,     so it naturally follows the <code>Tracer</code>.     (although the <code>Printer</code> knows to skip this part if there <em>is</em> no <code>Tracer</code>). Some Stoppers (eg. <code>SlowStopper</code>, <code>FloorStopper</code>)     inspect the trace to decide whether energy has converged,     so the &quot;latest&quot; energy should already be logged. Therefore, these too should follow the <code>Tracer</code>.</p><p>Please note that, because the callbacks are called prior to actually updating the ansatz,     the Tracer will usually log one last round of updates     which are not actually reflected in the ansatz. The only times this does not happen are if convergence is flagged by the protocol itself     rather than a Stopper callback (eg. all scores are essentially zero),     which is probably never. ^_^ This behavior seems fine, even desirable, to me, but if you&#39;d like to avoid it,     you could implement a Stopper which explicitly terminates by returning <code>true</code>     (rather than merely flagging the ansatz as converged, like basic Stoppers),     and listing that Stopper <em>prior</em> to the Tracer.</p><p><strong>Standard keys</strong></p><p>The actual keys used in the <code>data</code> argument are determined by the protocol,     so you may design custom callbacks to make use of the data in your custom protocols.</p><p>However, for the sake of modularity, it is worth keeping keys standardized when possible. Here is a list of recommended keys.</p><p><strong>Reserved keys</strong></p><ul><li><code>:iteration</code>: iteration count over all optimizations</li><li><code>:adaptation</code>: which iteration an adaptation occurred</li></ul><p>These keys are not part of <code>data</code> but are used in the running <code>trace</code>.</p><p><strong>Standard keys for <code>adapt!</code></strong></p><ul><li><code>:scores</code>: vector of scores for each pool operator</li><li><code>:selected_index</code>: index in the pool of the operator ADAPT plans to add</li><li><code>:selected_generator</code>: the actual generator object ADAPT plans to add</li><li><code>:selected_parameter</code>: the parameter ADAPT plans to attach to the new generator</li></ul><p>Protocols which add multiple generators in a single adaptation     may still use these same keys, replacing the values with vectors.</p><p><strong>Standard keys for <code>optimize!</code></strong></p><ul><li><code>:energy</code>: the result of evaluating the observable. Required for some Stoppers</li><li><code>:g_norm</code>: the norm of the gradient vector (typically ∞ norm, aka. largest element)</li><li><code>:elapsed_iterations</code>: the number of iterations of the present optimization run</li><li><code>:elapsed_time</code>: time elapsed since starting the present optimization run</li><li><code>:elapsed_f_calls</code>: number of function calls since starting the present optimization run</li><li><code>:elapsed_g_calls</code>: number of gradient calls since starting the present optimization run</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L1-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.FloorStopper" href="#ADAPT.Basics.Callbacks.FloorStopper"><code>ADAPT.Basics.Callbacks.FloorStopper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FloorStopper(threshold::Energy, floor::Energy)</code></pre><p>Converge once the energy has gotten close enough to some target value.</p><p>Called for <code>adapt!</code> only. Requires a preceding <code>Tracer(:energy)</code>.</p><p><strong>Parameters</strong></p><ul><li><code>threshold</code>: maximum energy difference before convergence</li><li><code>floor</code>: the target value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L512-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.ParameterPrinter" href="#ADAPT.Basics.Callbacks.ParameterPrinter"><code>ADAPT.Basics.Callbacks.ParameterPrinter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterPrinter(; io=stdout, adapt=true, optimize=false, ncol=8)</code></pre><p>Print the current ansatz parameters as neatly and compactly as I can think to.</p><p><strong>Parameters</strong></p><ul><li><code>io</code>: the IO stream to print to</li><li><code>adapt</code>: print parameters at each adaptation</li><li><code>optimize</code>: print parameters at each optimization iteration</li><li><code>ncol</code>: number of parameters to print in one line, before starting another</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L303-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.ParameterStopper" href="#ADAPT.Basics.Callbacks.ParameterStopper"><code>ADAPT.Basics.Callbacks.ParameterStopper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterStopper(n::Int)</code></pre><p>Converge once the ansatz reaches a certain number of parameters.</p><p>Called for <code>adapt!</code> only.</p><p><strong>Parameters</strong></p><ul><li><code>n</code>: the minimum number of parameters required for convergence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L415-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.ParameterTracer" href="#ADAPT.Basics.Callbacks.ParameterTracer"><code>ADAPT.Basics.Callbacks.ParameterTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterTracer()</code></pre><p>Add the ansatz parameters to the running trace, under the key <code>:parameters</code>.</p><p>Called for <code>adapt!</code> only.</p><p>Each parameter is stored as a column in a matrix; each row is a different iteration. The existing trace is padded with columns of 0.0     to match the current number of parameters before a new row is added.</p><p>Concatenating either rows or columns to a matrix is rather expensive     (it involves creating an entirely new matrix in each call),     so use this callback with care.</p><p>Please note that the default implementation of this callback is unsuitable     (or at least the matrix requires some post-processing)     if the AdaptProtocol reorders parameters,     or even simply inserts new parameters anywhere other than the end. If you need a parameter tracer for such protocols,     you&#39;re probably best off implementing a new callback from scratch. (Maybe you could implement some clever permutation in the <code>adapt!</code> call?     But remember the callback is called <em>before</em> the parameter is added!)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L176-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.Printer" href="#ADAPT.Basics.Callbacks.Printer"><code>ADAPT.Basics.Callbacks.Printer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Printer([io::IO=stdout,] keys::Symbol...)</code></pre><p>Print selected data keys at each iteration or adaptation.</p><p>The <code>keys</code> arguments are passed in the same way as <code>Tracer</code>;     see that method for some examples. Unlike <code>Tracer</code>, the first argument can be an <code>IO</code> object,     which determines where the printing is done. By default, it is the standard output stream, ie. your console,     or a file if you are redirecting output via <code>&gt;</code>. The <code>io</code> argument allows you to <em>explicitly</em> write to a file,     via Julia&#39;s <code>open</code> function.</p><p>If a key is not present in <code>data</code>, it is ignored. Thus, the same list of keys is used for calls from <code>adapt!</code> and <code>optimize!</code>,     so long as keys do not overlap (which should be avoided)!</p><p>The keys <code>:iteration</code> and <code>:adaptation</code> are treated specially. These keys will not appear directly in <code>data</code>,     and they should not be included in <code>keys</code>. If the <code>trace</code> contains these keys (ie. if a <code>Tracer</code> callback was also included),     they are used as &quot;section headers&quot;. Otherwise, they are skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L227-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.ScoreStopper" href="#ADAPT.Basics.Callbacks.ScoreStopper"><code>ADAPT.Basics.Callbacks.ScoreStopper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScoreStopper(threshold::Score)</code></pre><p>Converge if all scores are below a certain threshold.</p><p>Called for <code>adapt!</code> only.</p><p><strong>Parameters</strong></p><ul><li><code>threshold</code>: the maximum score</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L442-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.Serializer" href="#ADAPT.Basics.Callbacks.Serializer"><code>ADAPT.Basics.Callbacks.Serializer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Serializer(; ansatz_file=&quot;&quot;, trace_file=&quot;&quot;, on_adapt=false, on_iterate=false)</code></pre><p>Serialize the current state so that it can be resumed more easily.</p><p>Please note that robust serialization depends heavily on version control;     if the definition of a serialized type has changed since it was serialized,     it is very, very difficult to recover. Thus, serialization of this nature should be considered     somewhat transient and unreliable. It&#39;s good for restarting when your supercomputer crashes unexpectedly mid-job,     but not so good for long-term archival purposes.</p><p><strong>Parameters</strong></p><ul><li><code>ansatz_file</code>: file to save ansatz in (&quot;&quot; will skip saving ansatz)</li><li><code>trace_file</code>: file to save trace in (&quot;&quot; will skip saving trace)</li><li><code>on_adapt</code>: whether to serialize on adaptations</li><li><code>on_iterate</code>: whether to serialize in every optimization iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L358-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.SlowStopper" href="#ADAPT.Basics.Callbacks.SlowStopper"><code>ADAPT.Basics.Callbacks.SlowStopper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SlowStopper(threshold::Energy, n::Int)</code></pre><p>Converge if all energies in the past n iterations are within a certain range.</p><p>Called for <code>adapt!</code> only. Requires a preceding <code>Tracer(:energy)</code>.</p><p><strong>Parameters</strong></p><ul><li><p><code>threshold</code>: maximum energy range before convergence</p></li><li><p><code>n</code>: number of recent adaptations to check</p><p>This function will not flag convergence       before at least <code>n</code> adaptations have occurred.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L471-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Callbacks.Tracer" href="#ADAPT.Basics.Callbacks.Tracer"><code>ADAPT.Basics.Callbacks.Tracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tracer(keys::Symbol...)</code></pre><p>Add selected data keys at each iteration or adaptation to the running trace.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">Tracer(:energy)</code></pre><p>Including this callback in a <code>run!</code> call will fill the <code>trace</code> argument     with the energy at each optimization iteration,     as well as noting in which iteration each adaptation occurred. I cannot think of a circumstance when you will not want to trace at least this much.</p><pre><code class="nohighlight hljs">Tracer(:energy, :scores)</code></pre><p>This example shows the syntax to keep track of multiple data keys:     just list them out as successive arguments of the same <code>Tracer</code>. Do NOT include multiple instances of <code>Tracer</code> in the same run,     or you will record twice as many iterations as actually occurred! The <code>ParameterTracer</code> is a distinct type and is safe to use with <code>Tracer</code>.</p><p><strong>Other Notes</strong></p><p>If a key is not present in <code>data</code>, it is ignored. Thus, the same list of keys is used for calls from <code>adapt!</code> and <code>optimize!</code>,     so long as keys do not overlap (which should be avoided)!</p><p>The keys <code>:iteration</code> and <code>:adaptation</code> are treated specially. These keys will not appear directly in <code>data</code>,     and they should not be included in <code>keys</code>.</p><p>The <code>:iteration</code> value will simply increment with each call from <code>optimize!</code>. The <code>:adaptation</code> value will be set to the most recent <code>:iteration</code> value.</p><p>I highly recommend including at minimum <code>Tracer(:energy)</code>     with every single ADAPT run you ever do.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Callbacks.jl#L102-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Operators" href="#ADAPT.Basics.Operators"><code>ADAPT.Basics.Operators</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Operators</code></pre><p>A suite of common operators, especially useful for constructing operator pools.</p><p>TODO:     I haven&#39;t decided yet whether observables should live here or not.     If they do, I&#39;ll want to standardize the interface somehow.     In particular, the interface with pyscf for molecules is rather hazy.     I think we need a separate package which is a Julia wrapper for openfermion.     Then observables will generally be input as qubit operators from that package,         or perhaps we have a simple method that converts qubit operators to PauliSums,         so we have better control over the arithmetic being performed.     In any case, though I may evict them someday,         standard lattice systems like Hubbard and Heisenberg, not requiring openfermion,         may inhabit this module for the time being.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Operators.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Operators.hubbard_hamiltonian-Tuple{Int64, Any, Any}" href="#ADAPT.Basics.Operators.hubbard_hamiltonian-Tuple{Int64, Any, Any}"><code>ADAPT.Basics.Operators.hubbard_hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hubbard_hamiltonian(L::Int, U, t; pbc=false)</code></pre><p>Convenience constructor for a 1D nearest-neighbor Hubbard model with L sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Operators.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Operators.hubbard_hamiltonian-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any}} where T" href="#ADAPT.Basics.Operators.hubbard_hamiltonian-Union{Tuple{T}, Tuple{Matrix{T}, Any, Any}} where T"><code>ADAPT.Basics.Operators.hubbard_hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hubbard_jw(graph::Array{T,2}, U, t)</code></pre><p>A Hubbard Hamiltonian in the Jordan-Wigner basis.</p><p>Copied shamelessly from Diksha&#39;s ACSE repository.</p><p><strong>Parameters</strong></p><ul><li><code>graph</code>: an adjacency matrix identifying couplings. Must be symmetric.</li><li><code>U</code>: Coulomb interaction for all sites</li><li><code>t</code>: hopping energy for all couplings</li></ul><p><strong>Returns</strong></p><ul><li><code>PauliOperators.PauliSum</code>: the Hamiltonian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Operators.jl#L71-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.Operators.qubitexcitation-Tuple{Int64, Int64, Int64}" href="#ADAPT.Basics.Operators.qubitexcitation-Tuple{Int64, Int64, Int64}"><code>ADAPT.Basics.Operators.qubitexcitation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qubitexcitation(n::Int, i::Int, k::Int)
qubitexcitation(n::Int, i::Int, j::Int, k::Int, l::Int)</code></pre><p>Qubit excitation operators as defined in Yordanov et al. 2021.</p><p>Note that Yordanov&#39;s unitaries are defined as <code>exp(iθG)</code> rather than <code>exp(-iθG)</code>,     so variational parameters will be off by a sign.</p><p><strong>Parameters</strong></p><ul><li><code>n</code>: total number of qubits</li><li><code>i,j,k,l</code>: qubit indices as defined in Yordanov&#39;s paper.</li></ul><p><strong>Returns</strong></p><ul><li><p><code>PauliOperators.ScaledPauliVector</code>: the qubit excitation operator</p><p>Note that all Pauli terms in any single qubit excitation operator commute,       so the <code>ScaledPauliVector</code> representation is &quot;safe&quot;.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/Operators.jl#L28-L47">source</a></section></article><h3 id="Other-Modules"><a class="docs-heading-anchor" href="#Other-Modules">Other Modules</a><a id="Other-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Modules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.OptimizationFreeADAPT.OptimizationFree" href="#ADAPT.OptimizationFreeADAPT.OptimizationFree"><code>ADAPT.OptimizationFreeADAPT.OptimizationFree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptimizationFree</code></pre><p>The optimization protocol which just doesn&#39;t do anything.</p><p>There are no iterations, so there is no reason to callback. Contract obliged!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/optimizationfree/OptimizationFree.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{ADAPT.OverlapADAPT.Infidelity}" href="#Base.Matrix-Tuple{ADAPT.OverlapADAPT.Infidelity}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Matrix(infidelity)</code></pre><p>Convert an infidelity to a matrix.</p><p>This implementation assumes:</p><ul><li>The target state <code>infidelity.Φ</code> can be cast to a vector.</li><li>The reference state in <code>evaluate(infidelity, reference)</code> is always normalized.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/overlap/OverlapADAPT.jl#L10-L19">source</a></section></article><h3 id="MyPauliOperators"><a class="docs-heading-anchor" href="#MyPauliOperators">MyPauliOperators</a><a id="MyPauliOperators-1"></a><a class="docs-heading-anchor-permalink" href="#MyPauliOperators" title="Permalink"></a></h3><p>These methods should not be considered part of &quot;ADAPT&quot;,     but rather, destined for the <code>PauliOperators.jl</code> package. The only reason I document them here is that     the doc builder is configured to throw an error     if any doc strings aren&#39;t included in the documentation...</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.MyPauliOperators.cis!-Tuple{AbstractVector, PauliOperators.FixedPhasePauli, Any}" href="#ADAPT.Basics.MyPauliOperators.cis!-Tuple{AbstractVector, PauliOperators.FixedPhasePauli, Any}"><code>ADAPT.Basics.MyPauliOperators.cis!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>TODO: VERY SPECIFICALLY ASSERT that pauli xz=00 is to be interpreted as I,                                     pauli xz=10 is to be interpreted as X,                                     pauli xz=01 is to be interpreted as Z,                                 and pauli xz=11 is to be interpreted as Y,                                 despite the last usually being interpreted as iY.     Also clear this definition with Nick before putting it in his package...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADAPT.Basics.MyPauliOperators.measure_commutator-Tuple{Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Dict{PauliOperators.KetBitString{N}} where N, AbstractVector}}" href="#ADAPT.Basics.MyPauliOperators.measure_commutator-Tuple{Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Array{PauliOperators.ScaledPauli{N}, 1} where N, PauliOperators.AbstractPauli, PauliOperators.PauliSum}, Union{Dict{PauliOperators.KetBitString{N}} where N, AbstractVector}}"><code>ADAPT.Basics.MyPauliOperators.measure_commutator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_commutator(
    A::AnyPauli,
    B::AnyPauli,
    Ψ::Union{SparseKetBasis,AbstractVector},
)</code></pre><p>Calculate the expectation value of the commutator, ie. ⟨Ψ|[A,B]|Ψ⟩.</p><p>TODO: There <em>could</em> be a place for this in PauliOperators,         but it would need to be carefully fleshed out type by type.     A and B needn&#39;t be Hermitian in general (though I assume they are here),         so my intuition is rather lacking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L236-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{PauliOperators.PauliSum{N}, Array{PauliOperators.ScaledPauli{N}, 1}}} where N" href="#Base.:*-Union{Tuple{N}, Tuple{PauliOperators.PauliSum{N}, Array{PauliOperators.ScaledPauli{N}, 1}}} where N"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cross-type multiplication. Best to discourage ever doing this operation. Needed for a lazy commutator, but not necessarily needed long-term. We&#39;ll return pauli sum for now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Array{PauliOperators.ScaledPauli{N}, 1}, Dict{PauliOperators.KetBitString{N}, T}}} where {N, T}" href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Array{PauliOperators.ScaledPauli{N}, 1}, Dict{PauliOperators.KetBitString{N}, T}}} where {N, T}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Of course this one is missing... ^_^ Note strict typing in out, because Paulis themselves are strictly typed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N}" href="#Base.adjoint-Tuple{Array{PauliOperators.ScaledPauli{N}, 1} where N}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>TODO: Consult with Nick before adding this definition to PauliOperators.</p><p>I hesitate for two reasons:</p><ol><li><p>It is not &quot;lazy&quot;. It allocates a new array.  Not unprecedented but not ideal.  Not sure the proper way to make it lazy.</p></li><li><p>Column vector adjoint should properly be a row vector, rather than reversed.  Can&#39;t think of why we&#39;d ever use ScaledPauliVector as a column vector,      but its data type is so, properly.</p></li></ol><p>But, this definition achieves desired polymorphism in evolving by ScaledPauliVector,     so if Nick okays it, I&#39;m happy with it. The alternative is a dedicated <code>unevolve</code> function with a tedious special case     for unevolving ansatze whose generators are ScaledPauliVector...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L47-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{Dict{PauliOperators.KetBitString{N}} where N}" href="#Base.adjoint-Tuple{Dict{PauliOperators.KetBitString{N}} where N}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>TODO: This adjoint is not strictly &quot;lazy&quot;. But I don&#39;t think anyone will care.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/ADAPT.jl/blob/95e373be6e6382c892f3a633d3f47bb8398150cd/src/base/__paulioperators.jl#L70-L72">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 25 April 2024 17:27">Thursday 25 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
